# -*- coding: utf-8 -*-
"""preparing_input_values_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Kqp57o-hs-M_1yxV2m_sfVO8dlEUeb_4

#Imports
"""

pip install loguru

import pandas as pd
import numpy as np
import math
from loguru import logger
from pathlib import Path
import os
import glob
from functools import reduce
from google.colab import drive
from google.colab.data_table import DataTable

pd.options.display.float_format = '{:,.2f}'.format
DataTable.max_columns = 30
drive.mount('/content/gdrive')

month = 'Mai'
year = '2020'

"""# Get intervals

## Functions
"""

# log
def log(f, message, err):
    logger.warning(message.format(err=repr(err), f=f))
    raise type(err)(message.format(err=repr(err), f=f))


# get_path
def get_path():
    try:
        path = Path("gdrive", "MyDrive", "dados SOAN")
        return path
    except FileNotFoundError as err:
        raise err
    except Exception as err:
        raise log("get_path", "error in {f}: {err}", err)


# get_soan_path
def get_soan_path():
    path = get_path()
    try:
        path_soan = Path(path, "Cenarios primeiro semestre 2020")
        return path_soan
    except FileNotFoundError as err:
        raise err
    except Exception as err:
        log("get_soan_path", "error in {f}: {err}", err)


# get_path_ship_cargoes
def get_path_ship_cargoes():
    path = get_path()
    try:
        path_shipment_cargoes = Path(
            path, "Realizado - Operations Desk", "Shipment Cargoes.xlsx"
        )
        return path_shipment_cargoes
    except FileNotFoundError as err:
        raise err
    except Exception as err:
        log("get_path_ship_cargoes", "error in {f}: {err}", err)


# get_real_supply
def get_ship_cargoes(param):
    try:

        path = get_path_ship_cargoes()
        df = pd.read_excel(path)

        # filtering
        df = df.loc[(df["Origin Port"] == "Port A"), :]
        df["year"] = df["Origin ETA"].dt.year
        df["month"] = df["Origin ETA"].dt.month
        if param == "demand":
            df = df.loc[(df["Incoterm"] == "FOB"), :]

        # preparing data
        df["Product"] = df["Product"].astype("string")
        df_aux = df[["month", "Product", "Quantity (t)"]]
        if param == "demand":
            df_aux.rename(
                columns={"Quantity (t)": "Quantity Realized"}, inplace=True)
        else:
            df_aux.rename(
                columns={"Quantity (t)": "Amount Realized"}, inplace=True)

        df_aux = df_aux.groupby(["month", "Product"], as_index=False).sum()
        return df_aux
    except Exception as err:
        log("get_ship_cargoes", "error in {f}: {err}", err)


# get_path_berth()
def get_path_berth():
    path = get_path()
    try:
        path_berth = Path(
            path, "Realizado- Berth Outlfow Capacity"
        )
        return path_berth
    except FileNotFoundError as err:
        raise err
    except Exception as err:
        log("get_path_berth", "error in {f}: {err}", err)

def get_berth(port):
    try:

        path = get_path_berth()
        if port == 'Port A':
          path = str(path)+'/port-a/*.xlsx'

        if port == 'Porto B':
          path = str(path)+'/port-b/.xlsx'

        file_list = glob.glob(path)
        excel_list = []
        for file in file_list:
              df = pd.read_excel(file)
              excel_list.append(df)
        return excel_list[0]
    except Exception as err:
        log("get_data", "error in {f}: {err}", err)

# get_data
def get_data(year, month, file_title, path):

    try:
        path = "{path}/*{month}*{year}/*/*{file_title}.xlsx".format(
            path=str(path), month=str(month), year=str(year), file_title=str(file_title)
        )
        file_list = glob.glob(path)
        excel_list = []
        for file in file_list:
            df = pd.read_excel(file)
            excel_list.append(df)

        return excel_list
    except Exception as err:
        log("get_data", "error in {f}: {err}", err)


# merge_plan_real
def merge_plan_real(df_plan, df_real, how):
    try:
        df_merge = df_real.merge(df_plan, how=how)
        return df_merge
    except Exception as err:
        log("merge_plan_real", "error in {f}: {err}", err)


# get_fine_tune_eta
def get_fine_tune_eta(df_plan, df_real):
    try:
        return ""
    except Exception as err:
        log("get_fine_tune_eta", "error in {f}: {err}", err)


# get_fine_tune_berth
def get_fine_tune_berth(df_plan, df_real):
    try:
        diffs = []

        for idx, df in enumerate(df_plan):
            df_merge = merge_plan_real(df, df_real, "outer")
            df_merge["Monthly Outflow Capacity Realized"] = df_merge[
                "Monthly Outflow Capacity Realized"
            ].fillna(0)
            df_merge["Monthly Outflow Capacity " + str(idx)] = df_merge[
                "Monthly Outflow Capacity"
            ].fillna(0)
            df_merge = df_merge.drop(columns=["Monthly Outflow Capacity"])
            diffs.append(df_merge)
        return diffs
    except Exception as err:
        log("get_fine_tune_berth", "error in {f}: {err}", err)


# get_fine_tune_demand
def get_fine_tune_demand(df_plan, df_real):
    try:
        diffs = []

        for idx, df in enumerate(df_plan):
            df_merge = merge_plan_real(df, df_real, "outer")

            df_merge["Quantity Realized"] = df_merge["Quantity Realized"].fillna(
                0)
            df_merge["Quantity"] = df_merge["Quantity"].fillna(0)
            df_merge["div_quantity_" +
                     str(idx)] = (df_merge["Quantity Realized"] / df_merge["Quantity"])
            diffs.append(df_merge)

        return diffs
    except Exception as err:
        log("get_fine_tune_demand", "error in {f}: {err}", err)


# get_fine_tune_supply
def get_fine_tune_supply(df_plan, df_real):
    try:
        diffs = []

        for idx, df in enumerate(df_plan):
            df_merge = merge_plan_real(df, df_real, "outer")
            df_merge["Amount Realized"] = df_merge["Amount Realized"].fillna(0)
            df_merge["Amount"] = df_merge["Amount"].fillna(0)
            df_merge["div_amount_" + str(idx)] = (
                df_merge["Amount Realized"] / df_merge["Amount"]
            )
            diffs.append(df_merge)
        return diffs
    except Exception as err:
        log("get_fine_tune_supply", "error in {f}: {err}", err)


# get_fine_tune
def get_fine_tune(df_plan, df_real, variable):

    if (variable == 'supply'):
      return get_fine_tune_supply(df_plan, df_real)
    elif (variable == 'eta'):
      return get_fine_tune_eta(df_plan, df_real)
    elif (variable == 'berth'):
      return get_fine_tune_berth(df_plan, df_real)
    elif (variable == 'demand'):
      return get_fine_tune_demand(df_plan, df_real)
    else:
      Exception("Necessary inform a valid variable string")

# lp_seq
def lp_seq():
    return pd.DataFrame(
        {
            "s": [1, 2, 3, 4, 5, 6, 7],
            "t=1": [0.500, 0.250, 0.750, 0.125, 0.625, 0.375, 0.875],
            "t=2": [0.500, 0.750, 0.250, 0.625, 0.125, 0.375, 0.875],
            "t=3": [0.500, 0.250, 0.750, 0.875, 0.375, 0.625, 0.125],
            "t=4": [0.500, 0.750, 0.250, 0.875, 0.375, 0.125, 0.625],
        })



"""## Supply

### Functions
"""

# get_plan_supply
def get_plan_supply(excel_list):
    try:
        dfs = []

        for df in excel_list:
            # filtering
            df = df.loc[(df["Port*"] == "PMA"), :]
            df["year"] = df["Start Date*"].dt.year
            df["month"] = df["Start Date*"].dt.month
            # preparing data
            df_aux = df[["month", "Product*", "Amount*"]]
            df_aux.rename(
                columns={"month": "month",
                         "Product*": "Product", "Amount*": "Amount"},
                inplace=True,
            )
            df_aux["Product"] = df_aux["Product"].astype("string")
            df_aux = df_aux.groupby(["month", "Product"], as_index=False).sum()
            dfs.append(df_aux)
        return dfs
    except Exception as err:
        log("get_plan_supply", "error in {f}: {err}", err)

def get_final_supply(diffs):
    try:
        df = reduce(
            lambda df1, df2: pd.merge(df1, df2, on=["month", "Product"]), diffs
        )

        # filtering
        df = df.filter(
            regex="month|Product|div_amount*", axis=1
        )
        df.replace([np.inf, -np.inf], np.nan, inplace=True)
        df = df.fillna(0)



        # getting max_min values
        df_div_value = df.filter(regex="div_amount*", axis=1)
        df["min_value"] = df_div_value.min(axis=1)
        df["max_value"] = df_div_value.max(axis=1)
        df = df[df["max_value"] > 0]

        return df
    except Exception as err:
        log("get_final_supply", "error in {f}: {err}", err)

"""### Core"""

path = get_soan_path()

sheets = get_data(year, month, 'Supply', path)

plan_supply = get_plan_supply(sheets)

real_supply = get_ship_cargoes('supply')

diffs = get_fine_tune(plan_supply, real_supply, 'supply')

final_supply = get_final_supply(diffs)

final_supply

"""## Berth Outflow Capacity

### Functions
"""

def get_plan_berth(excel_list):
    try:
        dfs = []

        for df in excel_list:
            # filtering
            df["year"] = df["Date*"].dt.year
            df["month"] = df["Date*"].dt.month

            # preparing data

            df_aux = df[["month", "Berth*", "Monthly Outflow Capacity*"]]
            df_aux.rename(
                columns={
                    "month": "month",
                    "Berth*": "Berth",
                    "Monthly Outflow Capacity*": "Monthly Outflow Capacity",
                },
                inplace=True,
            )
            df_aux["Berth"] = df_aux["Berth"].astype("string")
            df_aux = (
                df_aux.groupby(["month", "Berth"], as_index=False)
                .sum()
                .sort_values("month")
            )
            dfs.append(df_aux)
        return dfs
    except Exception as err:
        log("get_plan_berth", "error in {f}: {err}", err)

# prepare_df_pma()

def prepare_df_pma(df):
    try:
        df.columns = ["year", "month", "1", "3N", "3S", "4N", "4S", "Total"]
        df = df.iloc[1:, :]
        df["month"] = df["month"].astype("string")
        df = df.loc[df.month.str.contains("\d"), :]
        df = df.fillna(0)
        df.reset_index(drop=True)
        df = pd.melt(
            df, id_vars=["year", "month", "Total"], value_name="Berth"
        ).sort_values("month")
        df.rename(
            columns={"variable": "Berth",
                    "Berth": "Monthly Outflow Capacity Realized"},
            inplace=True,
        )
        df = df.groupby(["month", "Berth"],
                        as_index=False).sum().sort_values("month")
        df["month"] = df["month"].astype(str).astype(int)
        df["Port*"] = "Ponta da Madeira"
        return df
    except Exception as err:
        log("prepare_df_pma", "error in {f}: {err}", err)

# prepare_df_tu(df_raw_tu)

def prepare_df_tu(df):
    try:
        df.columns = ["year", "month", "02", "1N", "1S", "Total"]
        df = df.iloc[1:, :]
        df["month"] = df["month"].astype("string")
        df = df.loc[df.month.str.contains("\d"), :]
        df = df.fillna(0)
        df.reset_index(drop=True)

        df = pd.melt(
            df, id_vars=["year", "month", "Total"], value_name="Berth"
        ).sort_values("month")

        df.rename(
            columns={"variable": "Berth",
                    "Berth": "Monthly Outflow Capacity Realized"},
            inplace=True,
        )
        df = df.groupby(["month", "Berth"],
                        as_index=False).sum().sort_values("month")
        df["month"] = df["month"].astype(str).astype(int)
        df["Port*"] = "Tubarao"

        return df
    except Exception as err:
        log("prepare_df_tu", "error in {f}: {err}", err)



# get_real_berth():
def get_real_berth():
    try:

        df_raw_pma = get_berth('Porto TMPM')
        df_raw_tub = get_berth('Porto TU')

        df_pma = prepare_df_pma(df_raw_pma)
        df_tub = prepare_df_tu(df_raw_tub)

        df_real = df_pma.merge(df_tub, on = ['Port*','year', 'month','Berth','Monthly Outflow Capacity Realized', 'Total'], how = 'outer').sort_values('month')

        return df_real
    except Exception as err:
        log("get_real_berth", "error in {f}: {err}", err)

# change_for_max_values


def change_for_max_values(a, b):
    return max([a,b])


# change_for_min_values
def change_for_min_values(a,b):
    return min([a,b])


# get_final_berth
def get_final_berth(diffs):
    try:
        df = reduce(
            lambda df1, df2: pd.merge(
                df1,
                df2,
                on=[
                    'Port*',
                    "month",
                    "Berth",
                    "Monthly Outflow Capacity Realized",
                    "year",
                    "Total",
                ],
            ),
            diffs,
        )
        df = df.filter(
            regex="Port*|month|Berth|Monthly Outflow Capacity Realized|Monthly Outflow Capacity 0",
            axis=1,
        )
        df.rename(
            columns={
                "Monthly Outflow Capacity Realized": "max_value",
                "Monthly Outflow Capacity 0": "min_value",
            },
            inplace=True,
        )
        # df_final_berth.replace([np.inf, -np.inf], np.nan, inplace=True)
        df = df.fillna(0)

        df["new_max"] =   df.apply(lambda x: change_for_max_values(x['max_value'], x['min_value']), axis=1)
        df["new_min"] =   df.apply(lambda x: change_for_min_values(x['max_value'], x['min_value']), axis=1)

        df.drop(['max_value', 'min_value'], inplace=True, axis=1)
        df.rename(columns={"new_max": "max_value","new_min": "min_value"},inplace=True)
        return df
    except Exception as err:
        log("get_final_berth", "error in {f}: {err}", err)

"""### Core"""

path = get_soan_path()

sheets = get_data(year,month,'Berth Outflow Capacity',path)

plan_berth = get_plan_berth(sheets)

real_berth = get_real_berth()

diffs = get_fine_tune(plan_berth, real_berth, 'berth')

final_berth = get_final_berth(diffs)



"""## ETA

### ETA - year-month
"""

path = get_soan_path()

sheets = get_data(year,month,'Vessel Calculated ETA',path)

ports = get_data(year,month,'Ports',path)

df_etas = []
for dataframe in sheets:
    df_eta = dataframe
    port = ports[0]
    df_eta["month"] = df_eta["ETA*"].dt.month
    df_port = port[["International Code*", "Name*"]]
    df_port.rename(
        columns={
            "International Code*": "Port*",
            "Name*": "Origin Port",
        },
        inplace=True,
    )

    df_eta = df_eta.merge(df_port, how="inner")
    df_eta.drop(["Port*"], inplace=True, axis=1)
    df_eta["vessel_IMO-month-Port-vessel_class"] = (
        df_eta["Vessel IMO*"].astype(str)
        + "-"
        + df_eta["month"].astype(str)
        + "-"
        + df_eta["Origin Port"].astype(str)
        + "-"
        + df_eta["Vessel Class"].astype(str)
    )
    df_eta = df_eta[
        ["Vessel IMO*", "ETA*", "month", "Origin Port", "vessel_IMO-month-Port-vessel_class"]
    ].sort_values("vessel_IMO-month-Port-vessel_class")

    df_etas.append(df_eta)
df_etas[0]

path = get_path_ship_cargoes()
df_ship_cargoes = pd.read_excel(path)

df_ship_cargoes['month'] = df_ship_cargoes['Origin ETA'].dt.month
df_ship_cargoes['IMO'] = df_ship_cargoes["IMO"].fillna(0.0).astype(int)
df_ship_cargoes['Vessel IMO*'] = df_ship_cargoes["IMO"]
df_ship_cargoes.drop(['IMO'], inplace=True, axis=1)

df_ship_cargoes['vessel_IMO-month-Port-vessel_class'] = (
    df_ship_cargoes['Vessel IMO*'].astype(str)
    + '-'
    + df_ship_cargoes['month'].astype(str)
    + '-'
    + df_ship_cargoes['Origin Port'].astype(str)
    + '-'
    + df_ship_cargoes['Vessel Class'].astype(str)
)
df_ship_cargoes = df_ship_cargoes[['vessel_IMO-month-Port-vessel_class', 'Origin ETA', 'Vessel IMO*','month']].sort_values('vessel_IMO-month-Port-vessel_class')
df_ship_cargoes

df_difs_eta = []

for idx, df_eta in enumerate(df_etas):
  max_date = df_eta['ETA*'].max()
  df_ship_cargoes_aux = df_ship_cargoes.loc[(df_ship_cargoes["Origin ETA"]<= max_date)]

  df_dif = df_eta.merge(df_ship_cargoes_aux, how = 'inner')
  df_dif['diff_days_' + str(idx)] = df_dif['Origin ETA'] - df_dif['ETA*']
  df_dif['diff_days_' + str(idx)] = (df_dif['diff_days_'+ str(idx)]/(np.timedelta64(1,'D')))
  df_difs_eta.append(df_dif)
df_difs_eta[1]

df_final_eta = reduce(lambda df1,df2: pd.merge(df1,df2,on=['vessel_IMO-month-Port-vessel_class', 'Vessel IMO*', 'month', 'Origin Port' ], how = 'outer'), df_difs_eta)
df_final_eta

df_final_eta.replace([np.inf, -np.inf], np.nan, inplace=True)
df_final_eta = df_final_eta.fillna(0)

df_div_value_eta = df_final_eta.filter(regex='diff_days_*', axis=1)
df_final_eta['min_value'] = df_div_value_eta.min(axis=1)
df_final_eta['max_value'] = df_div_value_eta.max(axis=1)

df_final_eta_filtered = df_final_eta.filter(regex='Vessel IMO*|vessel_IMO-month-Port-vessel_class|diff_days_*|min_value|max_value', axis=1)

#df_final_eta_filtered_aux = df_final_eta_filtered.loc[(df_final_eta_filtered['vesselIMO-month-Port'] == '9532549-4-Ponta da Madeira')]['min_value'].min()
#  df_sup_list_f1 = df_sup_list.loc[(df_sup_list["Start Date*"]>= '2021-12-01') &(df_sup_list["Start Date*"]<= '2022-06-30') ]
#df_final_eta_filtered_gb = df_final_eta_filtered.groupby(['vessel_IMO-month-Port-vessel_class', "min_value","max_value"], as_index=False)

df_final_eta_filtered = df_final_eta_filtered.loc[(df_final_eta_filtered["min_value"] > -50), :]


final_eta = df_final_eta_filtered



"""## Demand

### Functions
"""

# get_plan_demand
def get_plan_demand(excel_list):
    try:
        dfs = []
        for df in excel_list:
            # filtering
            df = df.loc[(df["Port Origin*"] == "PMA"), :]
            df = df.loc[(df["Incoterm*"] == "FOB"), :]
            df["year"] = df["Start Date*"].dt.year
            df["month"] = df["Start Date*"].dt.month
            # preparing data
            df_aux = df[["month", "Product*", "Quantity*"]]
            df_aux.rename(
                columns={
                    "month": "month",
                    "Product*": "Product",
                    "Quantity*": "Quantity",
                },
                inplace=True,
            )
            df_aux["Product"] = df_aux["Product"].astype("string")
            df_aux = df_aux.groupby(["month", "Product"], as_index=False).sum()
            dfs.append(df_aux)
        return dfs
    except Exception as err:
        log("get_plan_demand", "error in {f}: {err}", err)


# get_final_demand
def get_final_demand(diffs):
    try:

        df = reduce(lambda df1, df2: pd.merge(
            df1, df2, on=["month", "Product"]), diffs)
        df = df.filter(regex="month|Product|div_quantity*", axis=1)
        df.replace([np.inf, -np.inf], np.nan, inplace=True)
        df = df.fillna(0)

        df_div = df.filter(regex="div_quantity*", axis=1)
        df["min_value"] = df_div.min(axis=1)
        df["max_value"] = df_div.max(axis=1)
        df = df[df["max_value"] > 0]

        return df
    except Exception as err:
        log("get_final_demand", "error in {f}: {err}", err)

"""### Core"""

path = get_soan_path()

sheets = get_data(year,month,'Demand',path)

plan_demand = get_plan_demand(sheets)

real_demand = get_ship_cargoes('demand')

diffs = get_fine_tune(plan_demand, real_demand, 'demand')

final_demand = get_final_demand(diffs)

plan_demand[0]

plan_supply[0]

"""# Create LPτ-sequences

![Screen Shot 2022-05-29 at 18.38.29.png](data:image/png;base64,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lSFDhvi6I73CQaCRCRTZd/O4uEMwzdChQ3298Yy7jdqwe/bZZ+2Px8CBA83uu+9uRowYYRq1wN6D4tgyCCxYsMCceuqpgS9muv7lL39p3OGRuUBQw/73f//35sMPPzRjx471fxww7HLBTyYJCFx22WXmgAMO8OvsgAEDrD7pK3ReTh3ScnfRRRf5Ml1yySXlwVxDoCEINIL+lIOYPXu2rzv6Eo+DQCMSaIS+m8fFnQ7g68yYMWP880a1cxJ/sfvtb3/rF9KzYnWcOnWqx4QjBAoj4M7NCa2fGla2fv363OXCsMsdORnWSUD6IT0p/V33zqVXRbrSIZpnnXVWkaKQNwRCCTSi/ujLw5lnnunrtDv/LlR2PCFQNIFG6bu99957ZvPNN7c687d/+7fWtvHawUY17BItnqIV/rbaaitHE9y1Osy1117ruMNmnCeeeMK56qqrnO23394tPw4CxRH493//d+cPf/iD8+CDD1oh3DeUzh577OFoRcrzzjsvVLBDDz3UcefhhYaVe2piuvs1rty76vU555zj/PM//7MNZ/GUqpgIaAACX331lV1gYfr06XbBH7dxc8aNG2clc796V11EJUv98bC4b02dGTNm2EvptzuXyAviCIGGIFCP/jz55JPO8OHDI8mvRYM+/vjjJuO6Uw+cCy+80Pnoo4+c+fPn+6syu1/inccff9xp165dk2kQAQJ5E6in75aF/hx22GFWT2TrvPbaa47kGj9+vMXhGnYb3+Ip//3f/+2/+ZEli4NAIxJwV//y62mU+TjDhg0zHTt2jPR34403xioyX+xi4SJywQT01UG64LZido5BFHGy1B/l/9JLL5k2bdpYmdzG1rirzEYRizgQyJ1AXP156qmnIrU70sktttgiUnnc7XX89k96rL9evXoZt5Ma6X4iQaAoAnH7bmnrj7vqsq877gtEi+G2227z/Rr1i12ioZiffvqpadWqlS2kjuq0fv3110XVAfKFQCgBzfn0GrQvvvgiNE5enhh2eZEmnzQIvP76677uuF+400gyURqffPKJ6d27ty/TtGnTEqXHzRDIkkAj6I8WCzv33HONXr5rISKvLdQw6//8z//MsvikDYFEBIrsu2mhLm8182OOOcYvx0Zv2KmkGqPt/VDo2LNnT+PudeRD4AQCRRPwtjnQW8qiHYZd0U+A/OMQuOeee/zf9zwX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vUHSmx/PqQOrjq86xDgIFEkgaR098MADbV3WCxXPSQ9+/vOfW//OnTsHjLVZs2bZL+ovvPCCUSOrlxt6gfjFF194t/vHpLL5CXECgYwIJK2jcdsf9CejB0myhRBI0nd78sknbRvTu3fvgOyev/pYEydODITF0Z8ksgUyzeAikWGnBvpnP/uZuf/++wOilYJ79tlnA2FcQCBPAq+99po1njRM2J3/Gch69OjRVvGPOuqogH/phYbC6AVGmPvrX/9q3PlwRnl4TjqhvGbOnOl5VT2OGDHC5n/llVcG4sh49L5oLFy4MBDGBQTyJJC0jmpYsupy+dDiGTNm+HVceuS566+/3g5j9q5rHZPKVittwiCQBoGkdTRu+4P+pPHUSKMRCCTtu6m/pxeHv/zlLwPF0RQxjZ5SuzRs2LBAWFT9SSpbINMMLhIZdpJn6dKl5vvvvw+I9sc//tFCC+tMByJyAYGMCVx44YW2LmpIS7m78847bZiMM42tDnMrV64M87Z+RxxxhFHDW+reffddm+bixYtLvSvOv/76a2sU6sdl7ty5FeE9e/a06Vx88cUVYXhAIA8CadRRzWM48sgjK8R1F0Gx9Vv1f/r06X74aaedZk488UT/utpJGrJVSxt/CKRBII06Grf9QX/SeHKk0QgEkvbdVIZrr73W/OUvf6kozt/93d/Z9kdrLpS6qPqThmyl+aZ9ntiwKxfok08+sQtBqMHW21ocBIok4M13O//88yvEkPGleqq/N954oyK8lseLL75oDbPyL2qPPvqonWNaPheoPK3SsdxffvllebDt3Equk046qSIMDwjkQSDLOlqa9mOPPeYXZ5999jHXXHONf13tpPR+9KcaJfyLJJBlHa3W/qA/RT5x8k6TQFZ9N8nopb3vvvsGRI6qP979afcrA8IkuEjFsNP8IC2aosnxWtVv5513Nvpqh4NA0QQGDBhgDTe9uSl3ehvqGXalncvyeGHXhxxyiNEXu3J36623mm7dupnLL7/cLtAifdhmm23sghH33nuvH/2BBx6weWulvzB37rnn2vDyH56wuPhBIAsCWdbR2267zdZv6UbpEOmtttrKzk894YQTzC677GI233xz06tXL6MG9L333vOLmaVsfiacQCABgSzraLX2B/1J8MC4taEIZNV3W7t2rV0dXX2/0nUXVPio+pOVbGk9gFQMO81V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Gnr9GH399de57svFEKgVgb333tsL8sUXXxzd8v3337dulMzHjxs3Loovd/Doo4/aJZZYwl9z6aWXWtfzWZL18ccf9/dbccUVE2khXo3r0KFDE2luNMIedthhXmGeOnWqdaMU9p133rGulzaRjxMINIKA6qOMOhlm3333XVQEddqpPssQay3IYHOj2P5v/fXX99ddccUVJZe5UUCfps6XECQH/fr18/Fdu3Yt6ShEfgIpPotIIK/83Hvvvb7uH3nkkYnXO/zww328ZNNNL/NpblaIXWuttawbtbNq36QUf/zxx/ajjz7y5+owUVsTD8hPnAbHRSOQV3dzI3NeTj7//PPo1SQPkhu1X27GVhRfrfwU2fbJbdidf/75drXVVovgcACBIhGQQikhlhHn1iYkijZgwAAv3DvssEMiPn3y2WefWTcv2+e99tpr08nRue4v5dNNkYnidCAjUCNw+iHZYostojQprSrXHXfcEcVxAIEiEdhjjz18vXVTJxPFktKo+qy/F154IZHW0sm2227rr1HnSDq46cs+TR0b8SCZC89y02miJOQnQsFBQQnklR/V8VVWWcXefvvtiTd8/D+diJKLZ5991qf179/fyhDMCpIbN63Zd66EdOQnkOCziARqobupk3DVVVcteb3QibjNNttEadXKT5Ftn9yG3YEHHmjdOroIDgcQKBKBE044wSuFGmZPB7e2zaepwfvhhx/SydH5Xnvt5fOpkW4tnHvuudat4yvJdvDBB/t7LLXUUlGam+/t41599dUojgMIFIWAW9vglUEpjxqxTocePXr4+nvSSSelk8qeqyHV/TSdMx3celS7/fbbp6Otc8Dlr9F1bl1ElI78RCg4KCCBWsmP81Vg3bq6xBu6tapeJuIdlloqUC5st912VoprPCA/cRocF41ALXQ3dV7IQEwHjV6rPdGU/xCqlZ8i2z65DTtNrXELeAMbPiFQKAJhDcExxxxTUi4ZVBJu/bkFtiXpitB6vJBHU40V3nvvPT/1OL2+zieW+RfKscEGG0Q5NOdbayVYhxoh4aBABOJrCL755puSkqlDT7Kx5557lqSVi9hqq638NfFp0eXyhvh4OR5++OEQ7ddMID8RDg4KRiBeb2slP3pF5/zLbrjhhl6ONMrdWtA6InVepkfWaX9aI0d6IwkEnamtulu5smsUT+2WlsxoWmZroZz8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AAQgAAEIQAACdSGAYVcXzDwEAhCAAAQgAAEIQAACEIBA+xHAsGs/ttwZAhCAAAQgAAEIQAACEIBAXQhg2NUFMw+BAAQgAAEIQAACEIAABCDQfgQw7NqPLXeGAAQgAAEIQAACEIAABCBQFwLtati9/fbbpnPnzqZbt251eRkeAoFKCPz2229m7rnnriRrSZ5ff/3V/PTTT6ZLly4labWOeO2110z37t3NAgssUOtbcz8ItInA7NmzzZxzzmk6dOjQpuuRnzZh46L/IwTyyk8aQ0s6lp71xx9/mHnmmSd9WUXntD8VYSJTHQnk0d1CMaW/dezYMZyW/cwjP7NmzTIffPCB6dmzZ9n7t2dCzQ27O++804wePdqMHz/efPvtt2bYsGHm0EMPbc934N4QaJXA999/b44//nhz//33mxkzZpg111zTHHDAAWbw4MGtXvv777+bq6++2tx9991mwoQJ5ueff/YGl64/55xzIiX3ySefNAcddJBZeOGFzRxzzJG4r7XWn+teO++8sznjjDP8+UUXXWRuuOEGM99883mFWdcp74cffmhU5meeecb06dMncS9OIFBvAmPHjjUXXnihmTRpku/U2GyzzcyQIUPM8ssv32pRKpUfycVbb71lOnXqlLhnkB19SlF98MEHo85C5CeBipOCEsgjP+lXaknHCrJ23XXXGRlm6oDp1auXOfXUU83uu++evpVBfkqQEFEwAnl0t/Aqn3/+ubnrrrvMyJEjzbRp08ynn34akhKf1cjPjz/+6HWzeeed13eeSHeTvCl++vTpXt5uvfXWxP3rduIay5qEmTNn2l122UXaq910003tQw89ZH/55Zea3JubQCAPAWck2d69e1s3ymZvvvlm64wlu/HGG/u6OmjQoBZv7X4E7LrrrmuXXXZZO2LECPvUU0/Zs88+2zph9tfvv//+0fWPPvqoj5MMtPR38cUXR9c4ZTYz7zLLLGOdEh3l4wACjSLgOuesa7T87/vkyZPtJZdcYueaay675JJL2pdffrnFYlUjP0EmW5IdybAb9YueifxEKDgoKIE88hN/pdZ0rE8++cTrXquvvro966yz7PDhw+3mm28etS/nnXde/Hb+GPkpQUJEgQjk0d30Gt99952XAbVfoV1ZdNFFM9+wWvl56aWXonuGe+tTzxo4cKB1o4uZz6lHpEYHcgcptEsssYR1ow720ksvta5XNfc9uQEEakVg77339gIYN6jef/99X18liOPGjSv7qHvvvddfe+SRRybyHH744T5eQvzll1/6NBl9up8bgbPvvvuudUPx9qOPPor+rrnmGi/0ig/B9abaww47zEphnjp1qnW9rPadd96xrucoZOETAg0joPqoOu6m0/tGMhREDZfqujrxWgrVyM+WW25p11prLetG7azkU436xx9/7OVH51JYJSvxgPzEaXBcNAJ55Se8TyU6lhtF9zKpzssQ1I7069fPx3ft2rVE2UR+Aik+i0ggj+6m95Fx9corr/i/m266ycuBm1GV+arVys+oUaOsW5ZgJ06caGXkqZNTHZlff/115v3rGZnbsPvss8/sQgst5IFde+219Sw7z4JAqwQk1FJM1eng5lYn8g8YMMDX2x122CERHz9Rw7jKKqvY22+/PR5tH3/8cX+tlNtnn33Wp8k4k2JaLmyxxRbWTYeJknVvleuOO+6I4jiAQJEI7LHHHr6en3nmmYliyehS3dffCy+8kEiLn1QjP/3797cyBLOCm+Zs3TQX30CHdOQnkOCzqATyyo/eq1Idy02V9vKojsF4kF4WZFVyFALyE0jwWUQCeXW39Ds999xzXg406yMrVCs/559/vl1ttdWybtXwuNyG3V577eVh6QeMAIGiETjhhBN8/dQ0r3TQyJoaPCmMP/zwQzo5Onfzpa1bVxed68DN1fbXxg1GTT1260oT+cLJ888/7/PL+AtBo3p6/quvvhqi+IRAYQi4tQ1eNlRHNWKQDj169PD196STTkonJc4rlR9NNSsXtttuOyvDLx6QnzgNjotGoFbyU6mO9dVXX9ntt9++BINmiATDTrNGQkB+Agk+i0igFrpb/L3UAS85cM7o4tHRcbXyc+CBByY66qMbFeAgl2GntUrhB0NDkQrvvfeeH5pkfV0Bvl2KYMMagmOOOaaEhgyqUH9ff/31kvRyEc75it1www39terlqSTstNNONj0yqHWoWqvXyLnYlZSdPP+dBOJrCL755psSCBp9lvzsueeeJWktRVQrPy+++KI3MNMjg8hPS5RJazSBWshPLXSseDkefvjhCAvyE6HgoIAEaq27Pf300769cs65qnrbcvKz/vrrW+c8r6p71StzLsNOa5bUsC+++OLWeQy0K664oj9XnEYynMeler0Hz4FAJoE11ljD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OTLEN4pALduOH3/80UybNs307ds383XyyM+sWbPMBx98YHr27Jl57/aOzGXY7bzzzuatt94ynTp1SpTTWuvP9akflgcffNB069YtkYcTCNSTwPfff2+OP/54c//995sZM2aYNddc0xxwwAFm8ODBFRXjjTfeMH/961/NuHHjzLfffut/DLbeemtzxhlnRPX/ySefNAcddJBZeOGFzRxzzJG4b5CJ33//3UhudJ3CRRddZG644QYz33zzeYVZ1ynvhx9+aFTmZ555xvTp0ydxL04gUG8CY8eONRdeeKGZNGmS6dKli9lss83MkCFDzPLLL19RUSqRn7a0J8hPRfjJ1GACeeVHetTTTz9tRo4cae666y5z5plnmoEDB5a8ldqXq6++2lx33XVGhpk6YHr16mVOPfVUs/vuu5fkR35KkBBRMAJ5dbf463zyySfmqquuMk888YRvy1ZbbTUzceJEM++88/ps1ciPDEPpZrpWnSfS3SRvip8+fbqXt1tvvTX++PodOyWyzWHjjTeWBdfin1MC7K+//trmZ3AhBPIScEaS7d27t1VdvPnmm60zlmyou4MGDWr19q+88ort3LmzXWONNaxroO3nn39ujzvuOF/vt9pqq6h+P/rooy3KQpCViy++OHqmU2Yzr1lmmWWsU6KjfBxAoFEEhg0bZl2jZXfZZRc7efJke8kll9i55prLLrnkkvbll19utViVyk+QySAnWZ/p9gT5aRU/GRpMIK/8XH/99dZ1jCfaieHDh5e8lVNa7aabbmpXX311e9ZZZ1nl2XzzzaPrzjvvvJJrkJ8SJEQUiEBe3S3+Kv/85z+t63S3biDKXnDBBfbdd9+NJ9tq5eell16KZCveVqmtdJ0u1o0uJu5fzxONDrQ5bLnllnattdaybtTOvv/++1Zfwscff2w/+ugjf64fmMMOO6zN9+dCCNSCwN577+0FMG5Qqb66UTIf70bhWnzMFlts4fNJkENww/R28cUX9/GPPfaYj37qqaf8uRuB8z8abijey4LkQX/XXHONV5AVH4LrTfUyIoV56tSp1vWy2nfeece6nqOQhU8INIyA6qMaKimW3333XVQONVxqzKRIthYqlZ+2tCfIT2v0SW8kgVrIjxROdY7ob/311/dyd8UVV5S8lhtF92nqvAxB7Ui/fv18fNeuXUuUTeQnkOKziATy6m56p59++snuv//+XgY23HBD++abb2a+arXyM2rUKOuWJVg34melG6qT003ttF9//XXm/esZmcuw69+/v7333nszy+umpVk3LOl/jDIzEAmBOhBQYyjFVEacBDweBgwY4IV9hx12iEcnjtXroh4eKbE///xzIu3ggw/28aEnVMaZOjrKBSm4bjpMlKxGV+W64447ojgOIFAkAnvssYev427qV6JY6sQLvZQvvPBCIi1+Uo38VNueID9x0hwXkUBe+Um/07bbbuvl7tJLL00nWTdV2qepYzAerr322khWpZeFgPwEEnwWkUBe3S280ymnnOLr/yqrrGLd2rcQXfJZrfycf/751k3lLLlPESJyGXYzZ84s+w7bbbedVUNNgEAjCZxwwgleqDXNKx00siblVB0QP/zwQzrZn2sasZs/7fONGTMmkUcGoa6/7bbbfPwvv/xi3fq7RJ5w8vzzz/u8Mv5C0FQAXf/qq6+GKD4hUBgCbm2Dlw3VUU0zTocePXr4+nvSSSelk6LzauSn2vYE+Ykwc1BAArWQn/RrbbPNNl7mNB06Hb766iu7/fbbp6OtZohIhvWnWSMhID+BBJ9FJJBXd9M7aRTNOcrzOlxc98p632rl58ADD0x01Gfds1FxuQy7coV+8cUXvULQUk9uuWuJh0AtCYQ1BMccc0zJbWVQhQbv9ddfL0kPEWGIfpFFFrH33Xefj1Zv0vzzz2//9Kc/lYzkhevinzvttJNNjww+9NBD1i28LZkeE7+OYwg0ikB8DcE333xTUgyNPkt+9txzz5K0eERe+SnXniA/ccocF41AreQn/l5a0y2Ziy8riKdnHcfL8fDDD0dZkJ8IBQcFJFAL3c05uPPyonspaNbWc88955fGVPrK5eRH06LPOeecSm9T13ztYtjpx0cjdgQINJqAHJ6oITz33HNLiqIRgmDYxRu8dEbn0c+6LQeivOo1XWqppaymxaiXp7XgvJn5azVqFw+XX365XXrppe1pp53mnbksuuiiVsajFrw7b0rxrBxDoO4EnPc9X2/V45kVjjrqKJ++wQYbZCVHcXnlp1x7gvxEiDkoIIFayU/81cJ6VTl/qDRceeWVXk7VtsSXIyA/lRIkXyMI5NXdnCdZ7/ROOp6cCTmP5dHsK8W5bQ7se++91+qrlZOfhRZayPtH2G233eyqq67qn+W8RFsNIlRy31YfnCNDzQ07t7WB/xF59tlncxSLSyFQGwLBIMtabK5pYsGwu+WWW1p84L///W/vCTDk1+ehhx5adupl/Gbq2ZExmA5HHnmk/6HROgzN79aPz9prrx2VqaUpbul7cQ6BWhPQdC/Vc3kSywrOhbpPX2mllbKSE3FtlZ+W2hPkJ4GYk4IRqKX8hFeTsyLJZFjXHeLLfTrX674TUtc4N++JbMhPAgcnBSOQV3d7++23I11K9X/XXXe1f//73/1ot4wyxcmzsxw+lgvl5Eee0XW9HETKQ7rWvMpRpGZghfum17qWe0Z7xNfUsNNiXFnZGv4kQKAIBDQiJkHL6uHU9DKl6e+RRx4pW1yNOKheqzfG7RFkpciG67R4tqVRO3lOUl5tsZAOms6Z/lGRsbnjjjv6a+T0RT9OBMjriUsAAAnrSURBVAg0gkBwuqDGKiuoZ1J1e6ONNspKjuLaKj+ttSfIT4SYgwISqJX8xF9NXv0kc2effXY8uuyxpoopv0Yr0gH5SRPhvEgE8upu99xzj6/7qv/p7UG03k76ldJk7JUL5eRHTsEef/xxq1HBeJCeF+6rNXiNCjU17MIPmaaeESBQBAJhbyy3OXlJccLicQm3tuzICp9++qnVnnIdO3aMhtflJOXYY4+NfjT23XffrEut8q2wwgpWU8mqCcHRisqlPYwIEGgEgfi+jHIEkQ5quFRH99tvv3RSdJ5HftraniA/EX4OGkigFvKTLv56663nZS7tpTadT+fqrJQ7dl0Tn4KZlTceh/zEaXDcKAJ5dTftW6f2SX/a3iodgiOiuKfyeJ62yo+WoemZyy67bPx2dT2umWGnPY6WWGIJq72ICBAoCoGwf0lWvdT+cxJA9bBopCwrXHTRRT5P1lTKww8/3KcttthiWZfaIUOG+HTtb1dN0J534QcJw64acuStJYH4VJasOrzJJpv4eqo1ouVCW+UnT3uC/JT7NoivJ4FayE+6vH369GlV5nSN9urSdDON8FW7rxbyk6bOeSMI5NXdJk2aFOlRWgqQDkcccYRPX3fdddNJueTnkEMO8ff9P2HYhfUWGp4kQKAoBC677DIvZBpx0whaPKjXUwaUejTjQVPAQtAUFuWRsKbDE088Ed1bG5bHg+Zgd+nSxW622Wbx6MTx9OnT7emnn56I04kcuQTDTnkIEGgEAU03UaeF6mJ66pdGAMJ6ggceeCBRvFrITyXtCfKTwM5JwQjUQn7Sr6Q1PZJH7c1VLmh0QssG1JmZ3rdLjiC0aboC8lOOIPFFIJBXd9NSGzn+krzEt/kI7yYndUpL63aVys/JJ59ss9bRyZmY7rvPPvuER9X9syYjdtqsVhstr7POOnV/AR4IgZYIaH+6bt26eUEbMWJElFWNbs+ePX382LFjo/iBAwf69XQzZszwcfIcJiHV5pa6Jh5Gjhzp0+SpLB0GDRrk08L2COl0nSuPHFPEFWEdhwXy8rREgEAjCQwdOtTXYymK8elc2rtRcpH+za+F/FTaniA/jawZPLsSAnnlJ/2MsHfkiSeemE7y50Ep1fY6P//8cyKPZn9IZsO6beQngYeTghGoVnfTtgTyVh5fTycHd6rzGrmOB3Xyq7NfabfffnuUVKn8aInBXHPNZWV8xoOmb2pf5PR943nqcVwTwy4MacaB1qPwPAMClRBQb40ETe6eJfwy0DRSpri4URY2LFe8PIYpfPnll3bllVf2eeX1KCi3EyZM8PHavHzKlCmJYmhDWMXLoIwbbfFMmvqp8uhZ2qdLQb0/apAVp5ESTachQKCRBOQVbMUVV/R18uijj7Y6Vz1VA6re0LjToVrJTyXtCfLTyFrBsyslkFd+wnO+/fZbv4dq8BSorXbUBsWXEEybNs2vB1f7oZE9OfZSh4xkVW2N1tvJMFRAfgJZPotMoFLdTe8QOj1Uz2V4KWjbAXm+lExoyYB0P+lk8mSpuLC/nfJWIz/Dhg3z18vRnYLk6cYbb/Qd9bpv1r7JPmOd/uU27PSDEyxfrVkiQKCIBOSdsmvXrl4Y9al1dVIg49MzZUgpbcEFF0wYa1Jkg6dKpYcfEE3hlHeldAjTyLQGqVxQb+rgwYP9Ogjdc/HFF/dlk7I8YMCAzCH+cvciHgLtSUCdG6H+SzYkO1o/kN7SphbyU2l7gvy05zfOvWtJIK/8yFGXlFUpjOm/Tp062TFjxvjiavQ8nZ4+Dwon8lPLb5h7tSeBSnQ3PT/Mkkp7gNUMEE27lAxphpT2C1bHu/Q0jQqGUI38jBs3zo8C6p7du3eP9sdTZ4oMvLS3zPCMen120IOc8Lc5uLVFxvUcGdera5xl3Ob7cCEE2puA66kxr776qnHKo3GbU5rOnTuXPNIpp8YNpRu3pUFJ2hdffGFcr446Q0zv3r2NM8hK8ijCrV0wrgfHy4Tr9MjMEyJdD5JxU2OM+/ExzrgzbnTQuMY6JPMJgcIQUP2fOnWqcQ2Zr6dZBcsrP9W2J8hP1rdAXBEJtFV+nJJo9Oc6VHzbpPZJ52qH9OeUSx+ffmflkTxJRtQeOWPOuHXfifYF+UlT47yIBCrR3SQLbgaJcdutZcqDc8hlXnjhBS8DbhmOaU03q0R+Zs6caZxHdS9b0t3cFg2Zz64309yGXb0LzPMgAAEIQAACEIAABCAAAQhAIEkAwy7JgzMIQAACEIAABCAAAQhAAAJNRwDDrum+MgoMAQhAAAIQgAAEIAABCEAgSQDDLsmDMwhAAAIQgAAEIAABCEAAAk1HAMOu6b4yCgwBCEAAAhCAAAQgAAEIQCBJAMMuyYMzCEAAAhCAAAQgAAEIQAACTUcAw67pvjIKDAEIQAACEIAABCAAAQhAIEkAwy7JgzMIQAACEIAABCAAAQhAAAJNRwDDrum+MgoMAQhAAAIQgAAEIAABCEAgSQDDLsmDMwhAAAIQgAAEIAABCEAAAk1HAMOu6b4yCgwBCEAAAhCAAAQgAAEIQCBJAMMuyYMzCEAAAhCAAAQgAAEIQAACTUcAw67pvjIKDAEIQAACEIAABCAAAQhAIEkAwy7JgzMIQAACEIAABCAAAQhAAAJNRyBh2D344INm++23N507d266F6HAEIAABCAAAQhAAAIQgAAEmonArFmzzHXXXWcOPvjg3MVOGHaXXHKJ+Z//+R8z55xz5r4xN4AABCAAAQhAAAIQgAAEIACB8gR+//13c/TRR5srrriifKYKUxKG3cyZM82NN95orLUVXk42CEAAAhCAAAQgAAEIQAACEGgrgd1339306NGjrZdH1yUMuyiWAwhAAAIQgAAEIAABCEAAAhBoGgIYdk3zVVFQCEAAAhCAAAQgAAEIQAAC2QQw7LK5EAsBCEAAAhCAAAQgAAEIQKBpCGDYNc1XRUEhAAEIQAACEIAABCAAAQhkE8Cwy+ZCLAQgAAEIQAACEIAABCAAgaYhgGHXNF8VBYUABCAAAQhAAAIQgAAEIJBNAMMumwuxEIAABCAAAQhAAAIQgAAEmoYAhl3TfFUUFAIQgAAEIAABCEAAAhCAQDYBDLtsLsRCAAIQgAAEIAABCEAAAhBoGgIYdk3zVVFQCEAAAhCAAAQgAAEIQAAC2QQw7LK5EAsBCEAAAhCAAAQgAAEIQKBpCGDYNc1XRUEhAAEIQAACEIAABCAAAQhkE8Cwy+ZCLAQgAAEIQAACEIAABCAAgaYhgGHXNF8VBYUABCAAAQhAAAIQgAAEIJBNAMMumwuxEIAABCAAAQhAAAIQgAAEmoYAhl3TfFUUFAIQgAAEIAABCEAAAhCAQDYBDLtsLsRCAAIQgAAEIAABCEAAAhBoGgL/DwvrQwOErcT4AAAAAElFTkSuQmCC)
"""

lp_seq = lp_seq()



"""# Apply LPτ-sequences in Objective Function

![Screen Shot 2022-05-29 at 19.06.34.png](data:image/png;base64,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)

## Functions
"""

# get_cst
def get_cst(lp_seq, t, df_final, param):

    if param == "supply":
        df = df_final[["month", "Product", "min_value", "max_value"]]
    elif param == "eta":
        df = df_final[
                [
                       "Vessel IMO*",
                       "vessel_IMO-month-Port-vessel_class",
                        "min_value",
                        "max_value"
                  ]
        ]
    elif param == "berth":
        df = df_final
    elif param == "demand":
        df = df_final[["month", "Product", "min_value", "max_value"]]
    else:
        raise Exeption("Necessary inform a valid param.")

    for idx, q in enumerate(lp_seq["t=" + str(t)]):
        df["cst_" + str(idx + 1)] = 0
        df["cst_" + str(idx + 1)] = df["min_value"] + (
            (df["max_value"] - df["min_value"]) * q
        )
        if param == "supply":
            df.rename(columns={"Product": "Product*"}, inplace=True)
        elif param == "eta":
            df = df
        elif param == "berth":
            df.rename(columns={"Berth": "Berth*"}, inplace=True)
        elif param == "demand":
            df.rename(columns={"Product": "Product*"}, inplace=True)
        else:
            raise Exeption("Necessary inform a valid param.")
    return df

"""## Core"""

## t=1 supply
t = 1
supply_cst = get_cst(lp_seq, t, final_supply, "supply")

## t=2 eta
t = 2
eta_cst = get_cst(lp_seq, t, final_eta, 'eta')

## t=3 berth
t = 3
berth_cst = get_cst(lp_seq, t, final_berth, 'berth')

## t=4 demand
t = 4
demand_cst = get_cst(lp_seq, t, final_demand, 'demand')

supply_cst

"""# Fine-tune Objetive Functions

## Functions
"""

def get_input_supply(excel_list):
    inputs = []
    try:
        for df in enumerate(excel_list):
            df[1]['year'] = df[1]['Start Date*'].dt.year
            df[1]['month'] = df[1]['Start Date*'].dt.month
            inputs.append(df[1])
        return inputs
    except Exception as err:
        log("get_input_supply", "error in {f}: {err}", err)

def get_input_berth(excel_list):
    inputs = []
    try:
        for df in enumerate(excel_list):
             inputs.append(df[1])
        return inputs
    except Exception as err:
        log("get_input_berth", "error in {f}: {err}", err)

def get_input_demand(excel_list):
    inputs = []
    try:
        for df in enumerate(excel_list):
            df[1]['year'] = df[1]['Start Date*'].dt.year
            df[1]['month'] = df[1]['Start Date*'].dt.month
            inputs.append(df[1])
        return inputs
    except Exception as err:
        log("get_input_demand", "error in {f}: {err}", err)

def compare_values(old, new):
    try:
        if(old != float(0) and new == float(0)):
            return old
        return new
    except Exception as err:
        log("compare_values", "error in {f}: {err}", err)

def get_ajusted_inputs_supply(inputs, final_with_cst, variable):
    ed_inputs = []
    soan_cenarios = []
    for ed_input in inputs:
        df_aux = ed_input.merge(final_with_cst, how='outer')
        ed_inputs.append(df_aux)
    try:
        for ed_input in ed_inputs:
            final_inputs = []
            for idx, q in enumerate(lp_seq['t=1']):
                ed_input[str(variable) + '_' + str(idx+1)] = 0
                ed_input[str(variable) + '_' + str(idx+1)] = ed_input['Amount*'].multiply(
                    ed_input['cst_' + str(idx+1)], fill_value=0)

            for idx, q in enumerate(lp_seq['t=1']):
                orig_columns = inputs[0].columns.values.tolist()
                orig_columns.insert(-1, str(variable) + '_' + str(idx+1))
                df_aux = ed_input[orig_columns]
                df_aux[str(variable) + '_' + str(idx+1)] = df_aux.apply(lambda x: compare_values(
                    x['Amount*'], x[str(variable) + '_' + str(idx + 1)]), axis=1)
                df_aux.drop(['month', 'year', 'Amount*'], inplace=True, axis=1)
                df_aux.rename(columns={str(variable) + '_' +
                              str(idx+1): 'Amount*'}, inplace=True)
                df_aux = df_aux[df_aux['Port*'].notna()]

                final_inputs.append(df_aux)
            soan_cenarios.append(final_inputs)
        return soan_cenarios
    except Exception as err:
        log("get_ajusted_inputs_supply", "error in {f}: {err}", err)


def get_ajusted_inputs_eta(inputs, final_with_cst, variable):
    try:
        m = ''
        return m
    except Exception as err:
        log("get_ajusted_inputs_eta", "error in {f}: {err}", err)

def get_ajusted_inputs_berth(inputs, final_with_cst, variable):
    try:
        ed_inputs = []
        soan_cenarios = []
        for ed_input in inputs:
            ed_input['month'] = ed_input["Date*"].dt.month
            df_aux = ed_input.merge(final_with_cst, on =['month', 'Port*', 'Berth*'], how='inner')
            df_aux = df_aux.fillna(0)
            ed_inputs.append(df_aux)

        for ed_input in ed_inputs:
            final_inputs = []

            for idx, q in enumerate(lp_seq['t=3']):
                orig_columns = inputs[0].columns.values.tolist()
                orig_columns.insert(-1, 'cst_' + str(idx+1))
                df_aux = ed_input[orig_columns]
                df_aux['cst_' + str(idx+1)] = df_aux.apply(lambda x: compare_values(
                    x['Monthly Outflow Capacity*'], x['cst_'+str(idx + 1)]), axis=1)
                df_aux.drop(['Monthly Outflow Capacity*', 'month'],
                            inplace=True, axis=1)
                df_aux.rename(
                    columns={'cst_' + str(idx+1): 'Monthly Outflow Capacity*'}, inplace=True)
                final_inputs.append(df_aux)

            soan_cenarios.append(final_inputs)
        return soan_cenarios
    except Exception as err:
        log("get_ajusted_inputs_berth", "error in {f}: {err}", err)

def get_ajusted_inputs_demand(inputs, final_with_cst, variable):
    ed_inputs = []
    soan_cenarios = []
    for ed_input in inputs:
        df_aux = ed_input.merge(final_with_cst, how='outer')
        ed_inputs.append(df_aux)

    try:
        for ed_input in ed_inputs:
            final_inputs = []

            for idx, q in enumerate(lp_seq['t=4']):
                ed_input[str(variable) + '_' + str(idx+1)] = 0
                ed_input[str(variable) + '_' + str(idx+1)] = ed_input['Quantity*'].multiply(
                    ed_input['cst_' + str(idx+1)], fill_value=0)

            for idx, q in enumerate(lp_seq['t=4']):
                orig_columns = inputs[0].columns.values.tolist()
                orig_columns.insert(-1, str(variable) + '_' + str(idx+1))
                df_aux = ed_input[orig_columns]
                df_aux[str(variable) + '_' + str(idx+1)] = df_aux.apply(lambda x: compare_values(
                    x['Quantity*'], x[str(variable) + '_' + str(idx + 1)]), axis=1)
                df_aux.drop(['month', 'year', 'Quantity*'],
                            inplace=True, axis=1)
                df_aux.rename(
                    columns={str(variable) + '_' + str(idx+1): 'Quantity*'}, inplace=True)
                df_aux = df_aux[df_aux['Port Origin*'].notna()]
                final_inputs.append(df_aux)

            soan_cenarios.append(final_inputs)

        return soan_cenarios

    except Exception as err:
        log("get_ajusted_inputs_demand", "error in {f}: {err}", err)


# get_ajusted_inputs


def get_ajusted_inputs(inputs, final_with_cst, variable):
    if variable == "supply":
      return get_ajusted_inputs_supply(inputs, final_with_cst, variable)
    elif variable == "eta":
      return get_ajusted_inputs_eta(inputs, final_with_cst, variable)
    elif variable == "berth":
      return get_ajusted_inputs_berth(inputs, final_with_cst, variable)
    elif variable == "demand":
      return get_ajusted_inputs_demand(inputs, final_with_cst, variable)
    else:
      Exception("Necessary inform a valid variable string")

# core_supply()


def core_supply(cst, path):
    try:
        sheets = get_data(year, month, 'Supply', path)
        raw_data = get_input_supply(sheets)
        inputs = get_ajusted_inputs(raw_data, cst, 'supply')
        return inputs
    except Exception as err:
        log("core_supply", "error in {f}: {err}", err)

# core_eta()


def core_eta(cst, path):
    try:
        sheets = get_data(year, month, 'ETA', path)
        raw_data = get_input_supply(sheets)
        inputs = get_ajusted_inputs(raw_data, cst, 'eta')
        return inputs
    except Exception as err:
        log("core_eta", "error in {f}: {err}", err)

# core_berth()


def core_berth(cst, path):
    try:
        sheets = get_data(year, month, 'Berth Outflow Capacity', path)

        raw_data = get_input_berth(sheets)
        inputs = get_ajusted_inputs(raw_data, cst, 'berth')
        return inputs
    except Exception as err:
        log("core_berth", "error in {f}: {err}", err)

# core_demand()


def core_demand(cst, path):
    try:
        sheets = get_data(year , month, 'Demand', path)
        raw_data = get_input_demand(sheets)
        inputs = get_ajusted_inputs(raw_data, cst, 'demand')
        return inputs
    except Exception as err:
        log("core_demand", "error in {f}: {err}", err)

"""## Core"""

path = get_soan_path()
# Supply
inputs_supply = core_supply(supply_cst, path)

# ETA
inputs_eta = core_eta(eta_cst, path)

# Berth
inputs_berth = core_berth(berth_cst, path)

# Demand
inputs_demand = core_demand(demand_cst, path)

df_supply = inputs_supply[0][0]
df_supply["year"] = df_supply["Start Date*"].dt.year
df_supply["month"] = df_supply["Start Date*"].dt.month
df_supply['year-month'] = df_supply['Start Date*'].apply(lambda x: str(x.year) + '-' + str(x.month))
df_supply['port-product-year-month'] = df_supply['Port*'].astype(str) + '-' + df_supply['Product*'].astype(str) + '-' + df_supply['year-month'].astype(str)

df_demand = inputs_demand[0][0]
df_demand["year"] = df_demand["Start Date*"].dt.year
df_demand["month"] = df_demand["Start Date*"].dt.month
df_demand['year-month'] = df_demand['Start Date*'].apply(lambda x: str(x.year) + '-' + str(x.month))
df_demand['port-product-year-month'] = df_demand['Port Origin*'].astype(str) + '-' + df_demand['Product*'].astype(str) + '-' + df_demand['year-month'].astype(str)
df_demand

def max_value(incoterm,amount, quantity):
  if incoterm != 'FOB':
    return quantity
  elif quantity >= amount:
    return quantity
  else:
    return amount

def is_nan(old_value, new_value):
    try:
        if math.isnan(old_value):
            return new_value
        return old_value
    except Exception as err:
        log("is_nan", "error in {f}: {err}", err)

df = df_demand.merge(df_supply, how = 'outer')

df['max_values'] =   df.apply(lambda x: max_value(x['Incoterm*'], x['Amount*'], x['Quantity*']), axis=1)
df_x = df
orig_columns = inputs_demand[0][0].columns.values.tolist()
orig_columns.insert(-1, 'max_values')
orig_columns.remove('Product*')
orig_columns.remove('port-product-year-month')
orig_columns.remove('month')
orig_columns.remove('year')
orig_columns.remove('year-month')
df_aux = df[orig_columns]
df_aux.drop_duplicates(keep=False,inplace=True)
df_aux['max_values'] =   df.apply(lambda x: is_nan(x['max_values'], x['Quantity*']), axis=1)
df_aux.drop_duplicates(keep=False,inplace=True)

df_aux

"""# Export Objective Function

## Functions
"""

# remove_exist_file


def remove(path):
    try:
        os.remove(path)
    except OSError:
        pass

# get_soan_scenarios


def get_soan_scenarios(path, month, year):

    path = "{path}/*{month}*{year}/".format(
        path=str(path), month=str(month), year=str(year)
    )
    file_list = glob.glob(path)
    return file_list

# folder_names


def folder_names(folder_list):
    names = []
    for folder in folder_list:
        name = folder.split('/')[-2]
        names.append(name)
    return names

# create_folders


def create_folders(names, number_scenarios):
    path = Path('gdrive', 'MyDrive', 'input')

    for name in names:
        folder_path = str(str(path) + '/' + name)

        if os.path.exists(folder_path) == False:
            os.mkdir(folder_path)

        for n in range(0, number_scenarios):
            scenario_path = str(folder_path + '/scenario_' + str(n+1))
            if os.path.exists(scenario_path) == False:
                os.mkdir(scenario_path)


# create_files
def create_files(names, number_scenarios, inputs, file_name):
    path = Path('gdrive', 'MyDrive', 'input')
    for idx, name in enumerate(names):
        folder_path = str(str(path) + '/' + name)
        dfs = inputs[idx]
        for n in range(0, number_scenarios):
            df = dfs[n]
            scenario_path = str(folder_path + '/scenario_' + str(n+1))
            file_path = Path(str(scenario_path + '/' + file_name + '.xlsx'))
            remove(file_path)
            df.to_excel(excel_writer=file_path, index=False)
# prepare_export
def prepare_export():
    path = get_soan_path()
    folder_list = get_soan_scenarios(path, month, year)
    names = folder_names(folder_list)
    folders = create_folders(names, 7)
    return names

"""## Core"""

names = prepare_export()

create_files(names, 7,inputs_supply, 'Supply')
create_files(names, 7,inputs_supply, 'ETA')
create_files(names, 7,inputs_berth, 'Berth Outflow Capacity')
create_files(names, 7,inputs_demand, 'Demand')



"""## Max Quantity"""



"""- Pegar o cost analysis report em cada pasta, somar a coluna de quantidade, e colocar na diagonal da matriz.


- Pegar os valores das outras colunas da Matriz.
  -
"""

def get_path():
    try:
        path = Path("gdrive", "MyDrive")
        return path
    except FileNotFoundError as err:
        raise err
    except Exception as err:
        raise log("get_path", "error in {f}: {err}", err)


# get_soan_path
def get_otm_cenarios():
    path = get_path()
    try:
        path_aux = "{path}/input/Analisys/scenario_*/Cenario*.xlsx".format(
            path=str(path)
        )
        file_list = glob.glob(path_aux)
        #print(file_list)
        mydic = {}
        for idx,file in enumerate(file_list):
          path_2 = "{path}/input/Analisys/scenario_{idx}/Cenario*.xlsx".format(
              path=str(path), idx=str(idx+1)
          )
          file_list_2 = glob.glob(path_2)
        #  print(path_2)
          df = pd.read_excel(file_list_2[0])
          mydic["y"+ str(idx+1)] = df["Qtt (t)"].sum()

        return mydic
    except Exception as err:
          log("get_otm_cenarios", "error in {f}: {err}", err)




otm_values = get_otm_cenarios();



"""# Matriz pay-off and robust scenarios"""

# Used external tool for generate the Matriz pay-off (Software TDMCI License  BR512021003034-6)